---
title: 日志记录和拦截数据库操作的 EF6
author: divega
ms.date: 10/23/2016
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
ms.openlocfilehash: 3f06e073f3ab6e46883663620219e302d5db1d60
ms.sourcegitcommit: 2b787009fd5be5627f1189ee396e708cd130e07b
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/13/2018
ms.locfileid: "45490073"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="6c31c-102">日志记录和拦截数据库操作</span><span class="sxs-lookup"><span data-stu-id="6c31c-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="6c31c-103">**仅限 EF6 及更高版本** - 此页面中讨论的功能、API 等已引入实体框架 6。</span><span class="sxs-lookup"><span data-stu-id="6c31c-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="6c31c-104">如果使用的是早期版本，则部分或全部信息不适用。</span><span class="sxs-lookup"><span data-stu-id="6c31c-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="6c31c-105">应用程序代码可以截获从 Entity Framework 6 开始，只要实体框架发出命令到数据库下面的命令。</span><span class="sxs-lookup"><span data-stu-id="6c31c-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="6c31c-106">这最常用于日志记录 SQL，但也可以使用来修改或中止该命令。</span><span class="sxs-lookup"><span data-stu-id="6c31c-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="6c31c-107">具体而言，EF 包括：</span><span class="sxs-lookup"><span data-stu-id="6c31c-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="6c31c-108">类似于 LINQ to SQL 中 DataContext.Log 上下文日志属性</span><span class="sxs-lookup"><span data-stu-id="6c31c-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="6c31c-109">一种机制，以自定义内容并将输出发送到日志的格式设置</span><span class="sxs-lookup"><span data-stu-id="6c31c-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="6c31c-110">用于侦听提供更大的控制/灵活性的低级构建基块</span><span class="sxs-lookup"><span data-stu-id="6c31c-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="6c31c-111">上下文日志属性</span><span class="sxs-lookup"><span data-stu-id="6c31c-111">Context Log property</span></span>  

<span data-ttu-id="6c31c-112">DbContext.Database.Log 属性可以设置为采用字符串的任何方法的委托。</span><span class="sxs-lookup"><span data-stu-id="6c31c-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="6c31c-113">通常它是与使用任何 TextWriter 通过将其设置为该 TextWriter"Write"方法。</span><span class="sxs-lookup"><span data-stu-id="6c31c-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="6c31c-114">生成的当前上下文的所有 SQL 将都记录到该编写器。</span><span class="sxs-lookup"><span data-stu-id="6c31c-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="6c31c-115">例如，下面的代码会将 SQL 记录到控制台：</span><span class="sxs-lookup"><span data-stu-id="6c31c-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="6c31c-116">请注意，该上下文。Database.Log 设置为 Console.Write。</span><span class="sxs-lookup"><span data-stu-id="6c31c-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="6c31c-117">这是所有所需 SQL 记录到控制台。</span><span class="sxs-lookup"><span data-stu-id="6c31c-117">This is all that is needed to log SQL to the console.</span></span>  

<span data-ttu-id="6c31c-118">让我们添加一些简单的查询/插入/更新代码，以便我们可以看到一些输出：</span><span class="sxs-lookup"><span data-stu-id="6c31c-118">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="6c31c-119">这将生成以下输出：</span><span class="sxs-lookup"><span data-stu-id="6c31c-119">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="6c31c-120">（请注意，这是输出假定已发生的任何数据库初始化。</span><span class="sxs-lookup"><span data-stu-id="6c31c-120">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="6c31c-121">如果数据库初始化不已发生了则不会有更多输出显示了所有工作迁移实际执行了检查或创建新的数据库。）</span><span class="sxs-lookup"><span data-stu-id="6c31c-121">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

## <a name="what-gets-logged"></a><span data-ttu-id="6c31c-122">获取记录内容？</span><span class="sxs-lookup"><span data-stu-id="6c31c-122">What gets logged?</span></span>  

<span data-ttu-id="6c31c-123">日志属性时设置以下所有条件，将会记录：</span><span class="sxs-lookup"><span data-stu-id="6c31c-123">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="6c31c-124">SQL 的所有不同类型的命令。</span><span class="sxs-lookup"><span data-stu-id="6c31c-124">SQL for all different kinds of commands.</span></span> <span data-ttu-id="6c31c-125">例如：</span><span class="sxs-lookup"><span data-stu-id="6c31c-125">For example:</span></span>  
    - <span data-ttu-id="6c31c-126">查询，包括普通的 LINQ 查询、 eSQL 查询和方法，例如 SqlQuery 从原始查询</span><span class="sxs-lookup"><span data-stu-id="6c31c-126">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="6c31c-127">插入、 更新和删除的 SaveChanges 过程中生成的</span><span class="sxs-lookup"><span data-stu-id="6c31c-127">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="6c31c-128">加载查询，例如那些由延迟加载生成的关系</span><span class="sxs-lookup"><span data-stu-id="6c31c-128">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="6c31c-129">参数</span><span class="sxs-lookup"><span data-stu-id="6c31c-129">Parameters</span></span>  
- <span data-ttu-id="6c31c-130">在该值指示是否以异步方式执行命令</span><span class="sxs-lookup"><span data-stu-id="6c31c-130">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="6c31c-131">时间戳，指示该命令时开始执行</span><span class="sxs-lookup"><span data-stu-id="6c31c-131">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="6c31c-132">指示已成功完成，此命令失败，通过引发异常，或者，对于异步，已取消</span><span class="sxs-lookup"><span data-stu-id="6c31c-132">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="6c31c-133">结果值的提示</span><span class="sxs-lookup"><span data-stu-id="6c31c-133">Some indication of the result value</span></span>  
- <span data-ttu-id="6c31c-134">执行命令所用的时间近似量。</span><span class="sxs-lookup"><span data-stu-id="6c31c-134">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="6c31c-135">请注意，这是将命令发送到取回结果对象的时间。</span><span class="sxs-lookup"><span data-stu-id="6c31c-135">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="6c31c-136">它不包括读取结果的时间。</span><span class="sxs-lookup"><span data-stu-id="6c31c-136">It does not include time to read the results.</span></span>  

<span data-ttu-id="6c31c-137">看一下上面的示例输出，每个记录的四个命令是：</span><span class="sxs-lookup"><span data-stu-id="6c31c-137">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="6c31c-138">从上下文调用生成查询。Blogs.First</span><span class="sxs-lookup"><span data-stu-id="6c31c-138">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="6c31c-139">请注意，不会因为此查询起作用的 ToString 方法获取 SQL 的"First"不提供可以在其调用 ToString IQueryable</span><span class="sxs-lookup"><span data-stu-id="6c31c-139">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="6c31c-140">导致博客延迟加载的查询。文章</span><span class="sxs-lookup"><span data-stu-id="6c31c-140">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="6c31c-141">请注意发生的延迟加载的密钥值的参数详细信息</span><span class="sxs-lookup"><span data-stu-id="6c31c-141">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="6c31c-142">记录仅设置为非默认值的参数的属性。</span><span class="sxs-lookup"><span data-stu-id="6c31c-142">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="6c31c-143">例如，大小属性仅显示是否为非零。</span><span class="sxs-lookup"><span data-stu-id="6c31c-143">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="6c31c-144">两个命令因 SaveChangesAsync;一个用于更新更改文章标题，另一个用于插入操作将添加新文章</span><span class="sxs-lookup"><span data-stu-id="6c31c-144">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="6c31c-145">请注意的 FK 和 Title 属性的参数详细信息</span><span class="sxs-lookup"><span data-stu-id="6c31c-145">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="6c31c-146">请注意，以异步方式执行这些命令</span><span class="sxs-lookup"><span data-stu-id="6c31c-146">Notice that these commands are being executed asynchronously</span></span>  

## <a name="logging-to-different-places"></a><span data-ttu-id="6c31c-147">日志记录到不同的位置</span><span class="sxs-lookup"><span data-stu-id="6c31c-147">Logging to different places</span></span>  

<span data-ttu-id="6c31c-148">日志记录到如上所示控制台是非常容易。</span><span class="sxs-lookup"><span data-stu-id="6c31c-148">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="6c31c-149">它也很容易使用不同登录到内存、 文件等的[TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx)。</span><span class="sxs-lookup"><span data-stu-id="6c31c-149">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="6c31c-150">如果您熟悉 LINQ to SQL 可能注意在 LINQ to SQL 日志属性设置为实际 TextWriter 中的对象 (例如，Console.Out) 时的日志属性设置为一个方法接受字符串 （例如 EFConsole.Write 或 Console.Out.Write)。</span><span class="sxs-lookup"><span data-stu-id="6c31c-150">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (for example, Console.Out) while in EF the Log property is set to a method that accepts a string (for example, Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="6c31c-151">这样做的原因是 EF 从 TextWriter 分离通过接受任何可以作为字符串的接收器的委托。</span><span class="sxs-lookup"><span data-stu-id="6c31c-151">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="6c31c-152">例如，假设已有一些日志记录框架，它定义了日志记录方法如下所示：</span><span class="sxs-lookup"><span data-stu-id="6c31c-152">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="6c31c-153">这可以挂接到 EF Log 属性如下：</span><span class="sxs-lookup"><span data-stu-id="6c31c-153">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

## <a name="result-logging"></a><span data-ttu-id="6c31c-154">结果日志记录</span><span class="sxs-lookup"><span data-stu-id="6c31c-154">Result logging</span></span>  

<span data-ttu-id="6c31c-155">默认记录器命令文本 (SQL)、 参数和"正在执行"行使用记录时间戳之前的命令发送到数据库。</span><span class="sxs-lookup"><span data-stu-id="6c31c-155">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="6c31c-156">包含已用时间的"已完成"行是记录的执行以下命令。</span><span class="sxs-lookup"><span data-stu-id="6c31c-156">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="6c31c-157">请注意，对于异步命令的"已完成"的行不被记录直到异步任务实际完成、 失败，或被取消。</span><span class="sxs-lookup"><span data-stu-id="6c31c-157">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="6c31c-158">在"已完成"的行包含不同的信息，具体取决于命令和已成功执行的类型。</span><span class="sxs-lookup"><span data-stu-id="6c31c-158">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

### <a name="successful-execution"></a><span data-ttu-id="6c31c-159">成功执行</span><span class="sxs-lookup"><span data-stu-id="6c31c-159">Successful execution</span></span>  

<span data-ttu-id="6c31c-160">对于成功完成输出的命令是"已完成中的使用结果毫秒 x:"跟以及结果的提示。</span><span class="sxs-lookup"><span data-stu-id="6c31c-160">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="6c31c-161">指示返回的结果的数据读取器的命令是一种[DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx)返回。</span><span class="sxs-lookup"><span data-stu-id="6c31c-161">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="6c31c-162">返回一个整数值，例如更新的命令对于上面所示的结果所示的命令是该整数。</span><span class="sxs-lookup"><span data-stu-id="6c31c-162">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

### <a name="failed-execution"></a><span data-ttu-id="6c31c-163">执行失败</span><span class="sxs-lookup"><span data-stu-id="6c31c-163">Failed execution</span></span>  

<span data-ttu-id="6c31c-164">对于失败的命令都通过引发异常，输出包含来自异常的消息。</span><span class="sxs-lookup"><span data-stu-id="6c31c-164">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="6c31c-165">例如，使用 SqlQuery 对存在的表的查询将导致日志输出如下：</span><span class="sxs-lookup"><span data-stu-id="6c31c-165">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

### <a name="canceled-execution"></a><span data-ttu-id="6c31c-166">已取消的执行</span><span class="sxs-lookup"><span data-stu-id="6c31c-166">Canceled execution</span></span>  

<span data-ttu-id="6c31c-167">对于已取消任务的异步命令结果可能会失败并引发异常，因为这是基础 ADO.NET 提供程序通常的用途时尝试取消。</span><span class="sxs-lookup"><span data-stu-id="6c31c-167">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="6c31c-168">如果不会出现此问题，则输出将如下所示完全取消任务：</span><span class="sxs-lookup"><span data-stu-id="6c31c-168">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```  
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="6c31c-169">更改日志内容和格式设置</span><span class="sxs-lookup"><span data-stu-id="6c31c-169">Changing log content and formatting</span></span>  

<span data-ttu-id="6c31c-170">在后台 Database.Log 属性，则可以使用的 DatabaseLogFormatter 对象。</span><span class="sxs-lookup"><span data-stu-id="6c31c-170">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="6c31c-171">此对象有效地将 IDbCommandInterceptor 实现 （见下文） 绑定到一个委托，它接受字符串和 DbContext。</span><span class="sxs-lookup"><span data-stu-id="6c31c-171">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="6c31c-172">这意味着 DatabaseLogFormatter 上的方法通过 EF 调用之前和之后执行命令。</span><span class="sxs-lookup"><span data-stu-id="6c31c-172">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="6c31c-173">这些 DatabaseLogFormatter 方法收集和设置日志输出的格式并将其发送给该委托。</span><span class="sxs-lookup"><span data-stu-id="6c31c-173">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="6c31c-174">自定义 DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="6c31c-174">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="6c31c-175">更改记录的内容和它的格式可以通过创建从 DatabaseLogFormatter 派生而来并重写相应的方法的新类来实现。</span><span class="sxs-lookup"><span data-stu-id="6c31c-175">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="6c31c-176">若要重写的最常见方法是：</span><span class="sxs-lookup"><span data-stu-id="6c31c-176">The most common methods to override are:</span></span>  

- <span data-ttu-id="6c31c-177">LogCommand – 替代此设置以更改在执行前如何记录命令。</span><span class="sxs-lookup"><span data-stu-id="6c31c-177">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="6c31c-178">默认情况下 LogCommand LogParameter 调用为每个参数;您可以选择执行重写中相同的操作或改为以不同方式处理参数。</span><span class="sxs-lookup"><span data-stu-id="6c31c-178">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="6c31c-179">LogResult – 替代此设置以更改如何记录从执行命令的结果。</span><span class="sxs-lookup"><span data-stu-id="6c31c-179">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="6c31c-180">LogParameter – 替代此设置以更改格式设置和参数日志记录的内容。</span><span class="sxs-lookup"><span data-stu-id="6c31c-180">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="6c31c-181">例如，假设我们想要记录单个行，每个命令发送到数据库之前。</span><span class="sxs-lookup"><span data-stu-id="6c31c-181">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="6c31c-182">这可以通过两个替代：</span><span class="sxs-lookup"><span data-stu-id="6c31c-182">This can be done with two overrides:</span></span>  

- <span data-ttu-id="6c31c-183">重写 LogCommand 要格式化和写入单个 SQL 行</span><span class="sxs-lookup"><span data-stu-id="6c31c-183">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="6c31c-184">重写 LogResult 不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="6c31c-184">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="6c31c-185">该代码将如下所示：</span><span class="sxs-lookup"><span data-stu-id="6c31c-185">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="6c31c-186">若要记录输出只需调用 Write 方法，这会将输出发送到已配置的写入委托。</span><span class="sxs-lookup"><span data-stu-id="6c31c-186">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="6c31c-187">（请注意，此代码的作用只是为了举例简单删除换行符。</span><span class="sxs-lookup"><span data-stu-id="6c31c-187">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="6c31c-188">它可能不会适合查看复杂的 SQL。）</span><span class="sxs-lookup"><span data-stu-id="6c31c-188">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="6c31c-189">设置 DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="6c31c-189">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="6c31c-190">新的 DatabaseLogFormatter 类具有创建它后需要使用 EF 进行注册。</span><span class="sxs-lookup"><span data-stu-id="6c31c-190">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="6c31c-191">这是使用基于代码的配置。</span><span class="sxs-lookup"><span data-stu-id="6c31c-191">This is done using code-based configuration.</span></span> <span data-ttu-id="6c31c-192">简而言之，这意味着创建从 DbConfiguration 派生 DbContext 类为在同一程序集中的新类并在此新类的构造函数中调用 SetDatabaseLogFormatter。</span><span class="sxs-lookup"><span data-stu-id="6c31c-192">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="6c31c-193">例如：</span><span class="sxs-lookup"><span data-stu-id="6c31c-193">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="6c31c-194">使用新 DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="6c31c-194">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="6c31c-195">只要设置 Database.Log，现在将使用此新 DatabaseLogFormatter。</span><span class="sxs-lookup"><span data-stu-id="6c31c-195">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="6c31c-196">因此，第 1 部分中运行的代码现在将产生以下输出：</span><span class="sxs-lookup"><span data-stu-id="6c31c-196">So, running the code from part 1 will now result in the following output:</span></span>  

```  
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="6c31c-197">拦截构建基块</span><span class="sxs-lookup"><span data-stu-id="6c31c-197">Interception building blocks</span></span>  

<span data-ttu-id="6c31c-198">到目前为止，我们已经探讨如何使用 DbContext.Database.Log 记录生成的 EF 的 SQL。</span><span class="sxs-lookup"><span data-stu-id="6c31c-198">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="6c31c-199">但此代码通过用于更多常规侦听某些低级别构建基块是实际的相对较薄的外观。</span><span class="sxs-lookup"><span data-stu-id="6c31c-199">But this code is actually a relatively thin façade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="6c31c-200">拦截接口</span><span class="sxs-lookup"><span data-stu-id="6c31c-200">Interception interfaces</span></span>  

<span data-ttu-id="6c31c-201">拦截代码设计思路的拦截接口。</span><span class="sxs-lookup"><span data-stu-id="6c31c-201">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="6c31c-202">这些接口从 IDbInterceptor 继承，并定义当 EF 执行某些操作时调用的方法。</span><span class="sxs-lookup"><span data-stu-id="6c31c-202">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="6c31c-203">目的是对象的每个所拦截的类型有一个接口。</span><span class="sxs-lookup"><span data-stu-id="6c31c-203">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="6c31c-204">例如，IDbCommandInterceptor 接口定义 EF 进行对 ExecuteNonQuery、 ExecuteScalar、 ExecuteReader 和相关的方法的调用之前调用的方法。</span><span class="sxs-lookup"><span data-stu-id="6c31c-204">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="6c31c-205">同样，该接口定义这些操作完成时调用的方法。</span><span class="sxs-lookup"><span data-stu-id="6c31c-205">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="6c31c-206">我们在上面的 DatabaseLogFormatter 类实现此接口以记录的命令。</span><span class="sxs-lookup"><span data-stu-id="6c31c-206">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="6c31c-207">拦截上下文</span><span class="sxs-lookup"><span data-stu-id="6c31c-207">The interception context</span></span>  

<span data-ttu-id="6c31c-208">它查看任何拦截器接口上定义的方法是很明显，每次调用给定的对象类型 DbInterceptionContext 或某种类型派生自这如 DbCommandInterceptionContext\<\>。</span><span class="sxs-lookup"><span data-stu-id="6c31c-208">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="6c31c-209">此对象包含有关 EF 所用的操作的上下文信息。</span><span class="sxs-lookup"><span data-stu-id="6c31c-209">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="6c31c-210">例如，如果代表 DbContext 采取此操作后，然后在 DbContext 中包括 DbInterceptionContext。</span><span class="sxs-lookup"><span data-stu-id="6c31c-210">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="6c31c-211">同样，对于正在以异步方式执行的命令，则上 DbCommandInterceptionContext 设置 IsAsync 标志。</span><span class="sxs-lookup"><span data-stu-id="6c31c-211">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="6c31c-212">结果处理</span><span class="sxs-lookup"><span data-stu-id="6c31c-212">Result handling</span></span>  

<span data-ttu-id="6c31c-213">DbCommandInterceptionContext\< \>类包含名为结果、 OriginalResult、 异常和 OriginalException 属性。</span><span class="sxs-lookup"><span data-stu-id="6c31c-213">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="6c31c-214">这些属性设置为 null/零值对之前将执行此操作调用的拦截方法的调用 — 即，用于...正在执行的方法。</span><span class="sxs-lookup"><span data-stu-id="6c31c-214">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed — that is, for the …Executing methods.</span></span> <span data-ttu-id="6c31c-215">如果该操作执行，并且成功，则结果和 OriginalResult 将设置为运算的结果。</span><span class="sxs-lookup"><span data-stu-id="6c31c-215">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="6c31c-216">然后可以在执行该操作后调用的拦截方法中观察到这些值 — 也就是说，在...执行的方法。</span><span class="sxs-lookup"><span data-stu-id="6c31c-216">These values can then be observed in the interception methods that are called after the operation has executed — that is, on the …Executed methods.</span></span> <span data-ttu-id="6c31c-217">同样，如果该操作将引发，然后异常和 OriginalException 属性将设置。</span><span class="sxs-lookup"><span data-stu-id="6c31c-217">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="6c31c-218">取消执行</span><span class="sxs-lookup"><span data-stu-id="6c31c-218">Suppressing execution</span></span>  

<span data-ttu-id="6c31c-219">如果侦听器设置的 Result 属性之前执行了该命令 (在其中一个...然后 EF 执行方法） 不会尝试实际执行该命令，但将只需使用结果集。</span><span class="sxs-lookup"><span data-stu-id="6c31c-219">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="6c31c-220">换而言之，侦听器可以禁止显示命令的执行，但已有 EF 继续执行，如同已执行命令。</span><span class="sxs-lookup"><span data-stu-id="6c31c-220">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="6c31c-221">这可能会如何使用的一个示例是使用包装提供程序完成传统上了批处理，该命令。</span><span class="sxs-lookup"><span data-stu-id="6c31c-221">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="6c31c-222">侦听器将存储为一批的更高版本执行的命令，但将"假设"到该命令必须作为正常执行的 EF。</span><span class="sxs-lookup"><span data-stu-id="6c31c-222">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="6c31c-223">请注意，它比这更多需要实现批处理，但这是可能会如何使用更改拦截结果的示例。</span><span class="sxs-lookup"><span data-stu-id="6c31c-223">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="6c31c-224">此外可以通过将异常属性之一设置禁止显示执行...正在执行的方法。</span><span class="sxs-lookup"><span data-stu-id="6c31c-224">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="6c31c-225">这将导致 EF 来继续执行，如同通过引发给定的异常失败执行操作。</span><span class="sxs-lookup"><span data-stu-id="6c31c-225">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="6c31c-226">这可能，当然，会导致应用程序崩溃，但它也可能是暂时性异常或某种其他由 EF 处理的异常。</span><span class="sxs-lookup"><span data-stu-id="6c31c-226">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="6c31c-227">例如，这可以用于在测试环境中测试应用程序的行为，命令执行失败时。</span><span class="sxs-lookup"><span data-stu-id="6c31c-227">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="6c31c-228">在执行之后更改结果</span><span class="sxs-lookup"><span data-stu-id="6c31c-228">Changing the result after execution</span></span>  

<span data-ttu-id="6c31c-229">如果侦听器设置的 Result 属性执行该命令后 (在其中一个...执行方法） 则 EF 将使用已更改的结果，而不是从操作中实际返回的结果。</span><span class="sxs-lookup"><span data-stu-id="6c31c-229">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="6c31c-230">同样，如果执行该命令后，侦听器将设置异常属性，然后 EF 将引发集异常就像操作引发了异常的异常。</span><span class="sxs-lookup"><span data-stu-id="6c31c-230">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="6c31c-231">拦截器还可以将异常属性设置为 null 以指示应引发任何异常。</span><span class="sxs-lookup"><span data-stu-id="6c31c-231">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="6c31c-232">如果执行该操作失败，但拦截器希望 EF 来继续执行，如同该操作已经成功，这会很有用。</span><span class="sxs-lookup"><span data-stu-id="6c31c-232">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="6c31c-233">这通常还需要将结果设置，以便 EF 有一些结果值，因为它将继续使用。</span><span class="sxs-lookup"><span data-stu-id="6c31c-233">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="6c31c-234">OriginalResult 和 OriginalException</span><span class="sxs-lookup"><span data-stu-id="6c31c-234">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="6c31c-235">EF 执行某个操作后它会设置的结果和 OriginalResult 属性如果执行未失败或异常和 OriginalException 属性，如果执行失败，出现异常。</span><span class="sxs-lookup"><span data-stu-id="6c31c-235">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="6c31c-236">OriginalResult 和 OriginalException 属性是只读的并且实际执行某项操作后仅由 EF 设置。</span><span class="sxs-lookup"><span data-stu-id="6c31c-236">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="6c31c-237">这些属性不能通过侦听器设置。</span><span class="sxs-lookup"><span data-stu-id="6c31c-237">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="6c31c-238">这意味着任何侦听器可区分的异常或已由某些其他侦听器而不是实际异常设置的结果或执行操作时出现的结果。</span><span class="sxs-lookup"><span data-stu-id="6c31c-238">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="6c31c-239">注册侦听器</span><span class="sxs-lookup"><span data-stu-id="6c31c-239">Registering interceptors</span></span>  

<span data-ttu-id="6c31c-240">创建实现一个或多个侦听接口的类后可使用 EF 使用 DbInterception 类注册它。</span><span class="sxs-lookup"><span data-stu-id="6c31c-240">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="6c31c-241">例如：</span><span class="sxs-lookup"><span data-stu-id="6c31c-241">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="6c31c-242">此外可以在使用 DbConfiguration 基于代码的配置机制的应用程序域级别注册侦听器。</span><span class="sxs-lookup"><span data-stu-id="6c31c-242">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="6c31c-243">示例： 将日志写入 NLog</span><span class="sxs-lookup"><span data-stu-id="6c31c-243">Example: Logging to NLog</span></span>  

<span data-ttu-id="6c31c-244">让我们整理了所有这些示例到该使用 IDbCommandInterceptor 并[NLog](http://nlog-project.org/)到：</span><span class="sxs-lookup"><span data-stu-id="6c31c-244">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](http://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="6c31c-245">记录非异步执行任何命令一条警告</span><span class="sxs-lookup"><span data-stu-id="6c31c-245">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="6c31c-246">记录有关执行时，会引发任何命令的错误</span><span class="sxs-lookup"><span data-stu-id="6c31c-246">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="6c31c-247">下面是执行的日志记录，应注册，如上所示的类：</span><span class="sxs-lookup"><span data-stu-id="6c31c-247">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="6c31c-248">请注意此代码以发现命令非异步执行并发现时出错执行命令时如何使用拦截上下文。</span><span class="sxs-lookup"><span data-stu-id="6c31c-248">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
